# 박제민 202130138


## 3월 15일 강의
내용 정리  
자바 쓸 때 파일을 만들고 .java를 붙여서 자바 파일 생성

## 3월 22일 강의
**저급 언어** = 컴퓨터의 기본 언어  
**고급 언어** = 우리가 알고 있는 99%의 컴퓨터 언어  
자바 언어를 컴파일 하면 클래스
c/c++를 컴파일 하면 최종적으로 .exe파일  
**서블릿이란?** 웹서버에서 실행되는 자바 프로그램  
### 자바의 특성
1. 플랫폼 독립성
   * 하드웨어, 운영체제에 종속되지 않는 바이트 코드로 플랫폼 독립성
2. 객체 지향
   * 캡슐화 독립성
3. 클래스로 캡슐화  
   * 자바의 모든 변수나 함수는 클래스 내에 선언
   * 클래스 안에서 클래스(내부 클래스) 작성 가능
4. 소스와 클래스 파일
   * 하나의 소스파일에 여러 클래스르 작성 가능
   * 소스 파일의 이름과 public으로 선언된 클래스 이름은 같아야 함
   * 클래스 파일에는 하나의 클래스만 존재
5. 실행 코드 배포
   * 자바 응용 프로그램의 실행은 메소드에서 시작
6. 패키지
   * 서로 관련 있는 여러 클래스를 패키지로 묶어 관리
   * 패키지는 폴더 개념
7. 멀티 스레드 
   * 여러 스레드의 동시 수행 원격 지원
8. 가비지 컬렉션 
   * 자바 안에는 메모리의 할당 기능은 있어도 메모리의 반환 기능 없음
      * 사용하지 않는 메모리는 자바 가상 기계에 의해 자돈 반환-가비지 컬렉션
9. 실시간 응용프로그램에 부적합
    * 실행 도중 예측할 수 없는 시점에 가비지 컬렉션 실행 때문
10. 자바 프로그램은 안전
    * 타임 체크 엄격
    * 물리적 주소를 사용하는 포인터 개념 없음
11. 프로그램 작성 쉬움
    * 포인터 개념 없음 
    * 동적 메모리 반환 하지 않음
    * 다양한 라이브러리 지원
12. 실행 속도 개선을 위한 JIT 컴파일러 사용 
    * 자바는 바이트 코드를 인터프리터 방식으로 실행
      * 기계어가 실행되는 것보다 느림
    * JIT 컴파일 기법으로 실행 속도 개선  

### 식별자
**식별자란 ?** 
식별자란 클래스, 변수, 상수, 메소드에 붙이는 이름을 말한다.

### 자바의 기본 타입
**특징**  
기본 타입의 크기는 CPU나 운영체제에 따라 변하지 않음

### 문자열
* 문자열은 기본 타입이 아님
* String 클래스로 문자열 표현

### 변수
* 프로그램 실행 중에 값을 임시 저장하기 위한 공간

### 리터럴
* 프로그램에서 직접 표현한 값
* 정수, 실수, 문자, 논리, 문자열 리터럴 있음
* **실수 리터럴** 소수점 형태나 지수 형태로 표현한 실수
   * 실수리터럴은 double 사용
* **문자 리터럴** 단일 인용부호로 문자 표현
   * 특수문자 리터럴은 백슬레시(\)로 시작
* 논리 값 표시
   * true 또는 flase

### 상수
**상수 선언**
* final 키워드 사용
* 선언 시 조건값 지정
* 실행 중 값 변경 불가(다른 값을 추가 불가)  
### var 키워드
* JAVA 10부터 도입
* 기존의 변수 선업 방식 : 변수의 타입 반드시 지정
* var 키워드
  * 타입을 생략하고 변수 선언 가능
  * 캄파일러가 추론하여 변수 타입 결정
  * 변수 선언 시 초깃값이 주어지지 않으면 컴파일 오류
  * var는 지역 변수 선언에만 한정  

## 3월 29일 강의

### System.in
* 키보드와 연결된 자바의 표준 입력 스트림
* 입력되는 키를 바이트로 리턴하는 저수준 스트림
* System.in을 직접 사용하면 바이트를 문자나 숫자로 변환하는 많은 어려움 있음

### Scanner
* 읽은 바이트를 문자, 정수, 실수, 문자열 등 다양한 타입으로 변환하여 리턴
* 개발자가 원하는 타입 값으로 쉽게 읽을 수 있음

### 식과 연산자
* 연산
  * 주어진 식을 계산하여 결과를 얻어내는 과정
* 조건 연산
   * 3개의 피연산자로 구성된 상항 연산자
* 비트 연산
  * 비트 논리 연산
    * 비트끼리 AND, OR, XOR, NOT 연산
    * 비트를 오른쪽이나 왼쪽으로 이동

### 조건문
- 단순if문
  - if의 괄화 안에 조건식(논리형 변수나 논리 연산)
    - 실행문장이 단일 문장인 경우 둘러싸는 () 생략 가능
- if-else문
  - 조건식이 true면 실행문장1, false면 실행문장2 실행
- 다중 if-else문
  - 조건문이 너무 많은 경우, switch문 사용 
- switch문
  - switch문은 식과 case문의 값과 비교
    - care의 비교 값과 일치하면 해당 case의 실행문장 수행
    - case의 비교 값과 일치하는 것이 없으면 default문 실행
- case문의 값
  - 문자, 정수, 문자열 리터럴(JDK 1.7부터)만 허용
  - 실수 리터럴은 허용되지 않음

### 반복문

- for문
- while문
-continue문
  - 반복문을 빠져나가지 않으면서 즉시 다음 반복으로 넘어가고자할 떄 사용
- break문 
  - 반복문 하나를 즉시 벗어날 떄 사용
- 자바 배열
  - 배열 
   - 인덱스와 인덱스에 대응하는 데이터들로 이루어진 자료 구조
     - 배열을 이용하면 한 번에 많은 메모리 공간 선언 가능
   - 배열은 같은 타입의 데이터들이 순차적으로 저장되는 공간
   - 배열 인덱스
     - 0에서부터 시작
   - 배열 선언 
   - 배열 생성
   - 배열 초기화
- 배열과 for-each문
  - for문을 변형한 for-each문은 배열이나 나열의 크기만큼 루프를 돌면서 각 원소를 순차적으로 접근하는데 매우 유용하다
- 2차원 배열
  - 2차원 배열의 선언과 생성
    - 1차원 배열과 마찬가지로 2차원 배열에서도 레퍼런스 변수 선언 후 배열을 생성한다.
## 4월 5일 강의
### 반복문
- 예외
  - 실행 중 오동작이나 결과에 악영향을 미치는 예상치 못한 상황 발생
- 실행 중 예외가 발생하면
  - 자바 플랫폼은 응용프로그램이 예외를 처리하도록 호출
- 예외 발생 경우
  - 정수를 0으로 나누는 경우
  - 배열의 크기보다 큰 인덱스로 배열의 원소를 접근 하는 경우
  - 정수를 읽는 코드가 실행되고 있을 때 사용자가 문자를 입력한 경우
- 예외 처리
  - 발생한 예외에 대해 개발자가 작성한 프로그램 코드에ㅓ 대응하는 것
  - try-catch-filally문 사용
### 객체
- 캡슐화 : 객체를 캡슐로 싸서 ㅐ부를 볼 수 없게 하는 것
  - 객체의 가장 본질적인 특징
- 자바의 캡슐화 
  - 클래스 : 객체 모양을 선언한 틀(캡슐화하는 틀)
  - 객체 : 생성된 실체(instance)
    - 클래스 내에 메소드와 필드 구현
- 상속
  - 상위 개체의 속성이 하위 개체에 물려짐
  - 하위 개체가 상위 개체의 속성을 모두 가지는 관계
- 자바 상속
    - 상위 클래스의 멤버를 하위 클래스가 물려받음
      - 상위 클래스 : 수퍼 클래스
      - 하위 클래스 : 서브 클래스, 수퍼 클래스 코드의 재사용,  새로운 특성 추가 가능
- 다형성 
  - 같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 구현되는 것
  - 다형성 사례
    - 메소드 오버로딩 : 한 클래스 내에서 같은 이름이지만 다르게 작동하는 여러 메소드
    - 메소드 오버라이딩 : 슈퍼 클래스의 메소드를 동일한 이름으로 서브 클래스마다 다르게 구현
### 객체 지향 언어의 목적
- 소프트웨어의 생산성 향상
  - 컴퓨터 산업 발전에 따라 소프트 우어의 생명 주기 단축
   - 소프트웨어를 빠른 속도로 생산할 필요성 중대
  - 객체 지향 언어
    - 상속, 다양성, 객체, 캡슐화 등 소츠트웨어 재사용을 위한 여러 장치 내장
    - 소프트웨어 재사용과 부분 수정 빠름
    - 소프트웨어를 다시 만드는 부담 대폭 줄임
    - 소프트 웨어 생산성 향상
### 절차 지향 프로그래밍과 객체 지향 프로그래밍
- 절차 지향 프로그래밍
  - 작업 순서를 표현하는 컴퓨터 명령 집합
  - 함수들의 집합으로 프로그램 작성
- 객체 지향 프로그래밍
  - 컴퓨터가 수행하는 작업을 객체들간의 상호 작용으로 표현
  - 클래스 혹은 객체들의 집합으로 프로그램 작성 
### 클래스와 객체
- 클래스
  - 객체의 속성과 행위 선언
  - 객체의 설계도 혹은 틀
- 객체 
  - 클래스의 틀로 찍어낸 실체
    - 프로그램 실행 중에 생성되는 실체
    - 메모리 공간을 갖는 구체적인 실체
    - 인스턴스라고도 부름
- 사례 
  - 클래스: 소나타 자동차 - 객체: 출고된 실제 소나타 100대
  - 클래스: 벽시계  - 객체: 우리집 벽에 걸린 벽시계들
  - 클래스: 책상  - 객체: 우리가 사용중인 실제 책상
- 클래스
  - class 키워드로 선언
  - 멤버 : 클래스 구성요소
### 생성자
- 생성자 : 객체가 생성될 떄 초기화를 위해 실행 되는 메소드
- 클래스에 생성자가 선언되어 있는 경우
  - 컴파일러는 기본 생성자를 자동 생성해 주지 않는다.
### this 래퍼런스
- this 
  - 객체 자신에 대한 래퍼런스
    - 컴파일러에 의해 자동 관리, 개발자는 사용하기만 하면 됨
    - this 멤버 형태로 멤버를 접근할 떄 사용
- this()
  - 같은 클래스의 다른 생성자 호출
  - 생성자 내에서만 사용 가능
  -  생성자 코드의 제일 처음에 있어야 함
### 객체 배열
- 자바의 객체 배열
  - 객체에 대한 래퍼런스 배열
- 자바의 객체 배열 만들기 3단계
  - 배열 래퍼런스 변수 선언
  - 래퍼런스 배열 생성
  - 객체 생성
### 메소드
- 메소드
  - 메소드는 C/C++의 함수와 동일
  - 자바의 모든 매소드는 클래스안에 있어야 한다.
- 메소드 오버로딩
  - 오버로딩 
    - 한 클래스 내에서 두 개 이상의 이름이 같은 메소드 작성
      - 메소드 이름이 동일하여야 함
      - 메게 변수의 개수가 서로 다르거나, 타입이 서로 달라야 함
- 객체 소멸
  - new에 의해 할당 받은 객체와 배열 메모리를 자바 가상 기계로 되돌려 주는 행위
  - 소멸된 객체 고안은 가용 메모리에 포함
- 자바에서 사용자 임의로 객체 소멸안됨
  - 자바는 객체 소멸 연산자 없음
    - 객체 생성 연산자 : new
- 객체 소멸은 자바 가상 기계의 고유한 역할
- 자바 개발자에게는 매우 다행스러운 기능
  - C/C++에서는 할당 받은 객체를 개발자가 프로그램 내에서 삭제해야 함
  - C/C++의 프로그램 작성을 어렵게 만드는 요인
  - 자바에서는 사용하지 않는 객체나 배열을 돌려주는 코딩 책임으로부터 개발자 해방
### 가비지
  - 가비지 
    - 가리키는 래퍼런스가 하나도 없는 객체
      - 더 이상 접근할 수 없어 사용할 수 없게 된 메모리
  - 가비지 컬렉션
    - 자바 가상 기계의 가비지 컬렉터가 자동으로 가비지 수집, 반환
    - 자바 가상 기계가 가비지 자동 회수
      - 가용 메모리 공간이 일정 이하로 부족해질 떄
      - 가비지를 수거하여 가용 메모리 공간으로 확보
    - 가비지 컬렉터에 의해 자동 수행

  - 강제 가비지 컬렉션 강제 수행
    - system 또는 Runtime 객체의 gc() 메소드를 호출하여, 자바 플랫폼에 가비지 컬렉션을 요청할 수 있다
### 자바의 패키지 개념
  - 패키지
    - 상호 관련 있는 클래스 파일을 저장하여 관리하는 디렉터리
### 접근 지정자
  - 자바의 접근 지정자
    - 4가지
      - private, protected, public, 접근 지정자 생략(디폴트 접근 지정)
  - 접근 지정자의 목적
    - 클래스나 일부 멤버를 공개하여 다른 클래스에서 접근하도록 허용
    - 객체 지향 언어의 캡슐화 정책은 멤버를 보호하는 것
  - 클래스 접근지정
    - 다른 클래스에서 사용하도록 허용할 지 지정
    - public 클래스 
      - 다른 모든 클래스에게 접근 허용
    - 디폴트 클래스(접근지정자 생략)
      - 같은 패키지의 클래스에만 접근 허용
### static 멤버 사용
- 클래스 이름으로 접근 가능
- 객체의 멤버로 접근 가능
- non-static 멤버는 클래스 이름으로 접근 안 됨
